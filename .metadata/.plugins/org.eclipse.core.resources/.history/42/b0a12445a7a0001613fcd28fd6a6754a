package foldinglayout;
import sge.core.R;
import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.LinearGradient;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.graphics.Rect;
import android.graphics.Shader.TileMode;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewGroup;

/**
 * The folding layout where the number of folds, the anchor point and the
 * orientation of the fold can be specified. Each of these parameters can be
 * modified individually and updates and resets the fold to a default (unfolded)
 * state. The fold factor varies between 0 (completely unfolded flat image) to
 * 1.0 (completely folded, non-visible image).
 * 
 * This layout throws an exception if there is more than one child added to the
 * view. For more complicated view hierarchy's inside the folding layout, the
 * views should all be nested inside 1 parent layout.
 * 
 * This layout folds the contents of its child in real time. By applying matrix
 * transformations when drawing to canvas, the contents of the child may change
 * as the fold takes place. It is important to note that there are jagged edges
 * about the perimeter of the layout as a result of applying transformations to
 * a rectangle. This can be avoided by having the child of this layout wrap its
 * content inside a 1 pixel transparent border. This will cause an anti-aliasing
 * like effect and smoothen out the edges.
 * 
 */
public class BaseFoldingLayout extends ViewGroup {

	/*
	 * A bug was introduced in Android 4.3 that ignores changes to the Canvas
	 * state between multiple calls to super.dispatchDraw() when running with
	 * hardware acceleration. To account for this bug, a slightly different
	 * approach was taken to fold a static image whereby a bitmap of the
	 * original contents is captured and drawn in segments onto the canvas.
	 * However, this method does not permit the folding of a TextureView hosting
	 * a live camera feed which continuously updates. Furthermore, the sepia
	 * effect was removed from the bitmap variation of the demo to simplify the
	 * logic when running with this workaround."
	 */

	public static enum Orientation {
		VERTICAL, HORIZONTAL
	}

	private final String FOLDING_VIEW_EXCEPTION_MESSAGE = "Folding Layout can only 1 child at "
			+ "most";

	private final float SHADING_ALPHA = 0.8f;
	private final float SHADING_FACTOR = 0.5f;
	private final int DEPTH_CONSTANT = 1500;
	private final int NUM_OF_POLY_POINTS = 8;

	private Rect[] mFoldRectArray;

	private Matrix[] mMatrix;

	protected Orientation mOrientation = Orientation.HORIZONTAL;

	protected float mAnchorFactor = 0;
	private float mFoldFactor = 0;

	private int mNumberOfFolds = 2;

	private boolean mIsHorizontal = true;

	private int mOriginalWidth = 0;
	private int mOriginalHeight = 0;

	private float mFoldMaxWidth = 0;
	private float mFoldMaxHeight = 0;
	private float mFoldDrawWidth = 0;
	private float mFoldDrawHeight = 0;

	private boolean mIsFoldPrepared = false;
	private boolean mShouldDraw = true;

	private Paint mSolidShadow;
	private Paint mGradientShadow;
	private LinearGradient mShadowLinearGradient;
	private Matrix mShadowGradientMatrix;

	private float[] mSrc;
	private float[] mDst;

	private OnFoldListener mFoldListener;

	private float mPreviousFoldFactor = 0;

	private Bitmap mFullBitmap;
	private Rect mDstRect;

	public BaseFoldingLayout(Context context) {
		super(context);
	}

	public BaseFoldingLayout(Context context, AttributeSet attrs) {
		super(context, attrs);
		init(context, attrs);
	}

	public BaseFoldingLayout(Context context, AttributeSet attrs, int defStyle) {
		super(context, attrs, defStyle);
		init(context, attrs);
	}

	public void init(Context context, AttributeSet attrs) {
		// now style everything!
		TypedArray ta = context.obtainStyledAttributes(attrs,
				R.styleable.FoldingMenu);
		int mFoldNumber = ta.getInt(R.styleable.FoldingMenu_foldNumber,
				mNumberOfFolds);
		if (mFoldNumber > 0 && mFoldNumber < 7) {
			mNumberOfFolds = mFoldNumber;
		} else {
			mNumberOfFolds = 2;
		}
		ta.recycle();
	}

	@Override
	protected boolean addViewInLayout(View child, int index,
			LayoutParams params, boolean preventRequestLayout) {
		throwCustomException(getChildCount());
		boolean returnValue = super.addViewInLayout(child, index, params,
				preventRequestLayout);
		return returnValue;
	}

	@Override
	public void addView(View child, int index, LayoutParams params) {
		throwCustomException(getChildCount());
		super.addView(child, index, params);
	}

	@Override
	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
		View child = getChildAt(0);
		measureChild(child, widthMeasureSpec, heightMeasureSpec);
		setMeasuredDimension(widthMeasureSpec, heightMeasureSpec);
	}

	@Override
	protected void onLayout(boolean changed, int l, int t, int r, int b) {
		View child = getChildAt(0);
		child.layout(0, 0, child.getMeasuredWidth(), child.getMeasuredHeight());
		updateFold();
	}

	/**
	 * The custom exception to be thrown so as to limit the number of views in
	 * this layout to at most one.
	 */
	private class NumberOfFoldingLayoutChildrenException extends
			RuntimeException {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;

		public NumberOfFoldingLayoutChildrenException(String message) {
			super(message);
		}
	}

	/**
	 * Throws an exception if the number of views added to this layout exceeds
	 * one.
	 */
	private void throwCustomException(int numOfChildViews) {
		if (numOfChildViews == 1) {
			throw new NumberOfFoldingLayoutChildrenException(
					FOLDING_VIEW_EXCEPTION_MESSAGE);
		}
	}

	public void setFoldListener(OnFoldListener foldListener) {
		mFoldListener = foldListener;
	}

	/**
	 * Sets the fold factor of the folding view and updates all the
	 * corresponding matrices and values to account for the new fold factor.
	 * Once that is complete, it redraws itself with the new fold.
	 */
	public void setFoldFactor(float foldFactor) {
		if (foldFactor != mFoldFactor) {
			mFoldFactor = foldFactor;
			calculateMatrices();
			invalidate();
		}
	}
	


	public void setOrientation(Orientation orientation) {
		if (orientation != mOrientation) {
			mOrientation = orientation;
			updateFold();
		}
	}

	public void setAnchorFactor(float anchorFactor) {
		if (anchorFactor != mAnchorFactor) {
			mAnchorFactor = anchorFactor;
			updateFold();
		}
	}

	public void setNumberOfFolds(int numberOfFolds) {
		if (numberOfFolds != mNumberOfFolds) {
			mNumberOfFolds = numberOfFolds;
			updateFold();
		}
	}

	public float getAnchorFactor() {
		return mAnchorFactor;
	}

	public Orientation getOrientation() {
		return mOrientation;
	}

	public float getFoldFactor() {
		return mFoldFactor;
	}

	public int getNumberOfFolds() {
		return mNumberOfFolds;
	}

	private void updateFold() {
		prepareFold(mOrientation, mAnchorFactor, mNumberOfFolds);
		calculateMatrices();
		invalidate();
	}

	/**
	 * This method is called in order to update the fold's orientation, anchor
	 * point and number of folds. This creates the necessary setup in order to
	 * prepare the layout for a fold with the specified parameters. Some of the
	 * dimensions required for the folding transformation are also acquired
	 * here.
	 * 
	 * After this method is called, it will be in a completely unfolded state by
	 * default.
	 * 初始化准备，为变量赋值
	 * 
	 * 这个方法从名字就可以看出来是用于数据初始化，开始时初始化setPolyToPoly方法参数数组，
	 * 然后设置了画笔、折叠方向、折叠线附近的折叠效果灯。最重要的就是初始化这两个参数：
	 *  private Rect[] mFoldRectArray：private Matrix [] mMatrix：
	 *   他们分别根据折叠的数目来赋值。
	 * 
	 */
	private void prepareFold(Orientation orientation, float anchorFactor,
			int numberOfFolds) {
		//setPolyToPoly方法参数
		mSrc = new float[NUM_OF_POLY_POINTS];
		mDst = new float[NUM_OF_POLY_POINTS];
		//
		mDstRect = new Rect();

		mFoldFactor = 0;
		mPreviousFoldFactor = 0;
		//是否折叠
		mIsFoldPrepared = false;
		//画笔
		mSolidShadow = new Paint();
		mGradientShadow = new Paint();
		//方向
		mOrientation = orientation;
		mIsHorizontal = (orientation == Orientation.HORIZONTAL);
		//折叠线附近的效果
		if (mIsHorizontal) {
			mShadowLinearGradient = new LinearGradient(0, 0, SHADING_FACTOR, 0,
					Color.BLACK, Color.TRANSPARENT, TileMode.CLAMP);
		} else {
			mShadowLinearGradient = new LinearGradient(0, 0, 0, SHADING_FACTOR,
					Color.BLACK, Color.TRANSPARENT, TileMode.CLAMP);
		}
		//折叠线附近的效果
		mGradientShadow.setStyle(Style.FILL);
		mGradientShadow.setShader(mShadowLinearGradient);
		mShadowGradientMatrix = new Matrix();

		mAnchorFactor = anchorFactor;
		mNumberOfFolds = numberOfFolds;

		mOriginalWidth = getMeasuredWidth();
		mOriginalHeight = getMeasuredHeight();

		mFoldRectArray = new Rect[mNumberOfFolds];
		mMatrix = new Matrix[mNumberOfFolds];

		for (int x = 0; x < mNumberOfFolds; x++) {
			mMatrix[x] = new Matrix();
		}

		int h = mOriginalHeight;
		int w = mOriginalWidth;

		if (Util.IS_JBMR2 &&h!=0 &&w!=0) {
			mFullBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
			Canvas canvas = new Canvas(mFullBitmap);
			getChildAt(0).draw(canvas);
		}
		//折叠成几个部分，每隔部分的宽
		int delta = Math.round(mIsHorizontal ? ((float) w)
				/ ((float) mNumberOfFolds) : ((float) h)
				/ ((float) mNumberOfFolds));

		/*
		 * Loops through the number of folds and segments the full layout into a
		 * number of smaller equal components. If the number of folds is odd,
		 * then one of the components will be smaller than all the rest. Note
		 * that deltap below handles the calculation for an odd number of folds.
		 */
		for (int x = 0; x < mNumberOfFolds; x++) {
			if (mIsHorizontal) {
				int deltap = (x + 1) * delta > w ? w - x * delta : delta;
				mFoldRectArray[x] = new Rect(x * delta, 0, x * delta + deltap,
						h);
			} else {
				int deltap = (x + 1) * delta > h ? h - x * delta : delta;
				mFoldRectArray[x] = new Rect(0, x * delta, w, x * delta
						+ deltap);
			}
		}

		if (mIsHorizontal) {
			mFoldMaxHeight = h;
			mFoldMaxWidth = delta;
		} else {
			mFoldMaxHeight = delta;
			mFoldMaxWidth = w;
		}
		//设置已经准备就绪
		mIsFoldPrepared = true;
	}

	/*
	 * 这个方法是计算的核心部分
	 * Calculates the transformation matrices used to draw each of the separate
	 * folding segments from this view.
	 * 计算转换矩阵，用于绘制每个单独的折叠部分
	 * 
	 * 首先根据mFoldFactor得到cTranslationFactor，mFoldFactor是根据手指滑动的距离得到的，
	 * 是一个很小的数值，如果滑动距离小的话每次只有0.0几的变化。
	 * 所以得到的cTranslationFactor就像是一个百分比一样，来计算相对的数值。
	 * 然后根据cTranslationFactor计算出translatedDistance、mFoldDrawWidth、depth等
	 * 
	 */
	private void calculateMatrices() {
		// 设置可以绘图了
		mShouldDraw = true;
		// 没有准备好 返回
		if (!mIsFoldPrepared) {
			return;
		}

		/**
		 * If the fold factor is 1 than the folding view should not be seen and
		 * the canvas can be left completely empty.
		 */
		if (mFoldFactor == 1) {
			// 已经完全折叠了不需要绘制了
			mShouldDraw = false;
			return;
		}
		// 折叠结束
		if (mFoldFactor == 0 && mPreviousFoldFactor > 0
				&& mFoldListener != null) {

			mFoldListener.onEndFold();
		}
		// 折叠开始
		if (mPreviousFoldFactor == 0 && mFoldFactor > 0
				&& mFoldListener != null) {

			mFoldListener.onStartFold();
		}
		// 已经折叠了，将当前的折叠因子赋值到已经折叠过的折叠因子
		mPreviousFoldFactor = mFoldFactor;

		/*
		 * Reset all the transformation matrices back to identity before
		 * computing the new transformation
		 */
		for (int x = 0; x < mNumberOfFolds; x++) {
			mMatrix[x].reset();
		}
		//根据折叠因子来得到相对系数
		float cTranslationFactor = 1 - mFoldFactor;
		//计算整体变换的距离
		float translatedDistance = mIsHorizontal ? mOriginalWidth
				* cTranslationFactor : mOriginalHeight * cTranslationFactor;
		//得到每一个折叠视图变换的移动距离
		float translatedDistancePerFold = Math.round(translatedDistance
				/ mNumberOfFolds);

		/*
		 * For an odd number of folds, the rounding error may cause the
		 * translatedDistancePerFold to be grater than the max fold width or
		 * height.
		 */
		//计算出被画视图的宽度
		mFoldDrawWidth = mFoldMaxWidth < translatedDistancePerFold ? translatedDistancePerFold
				: mFoldMaxWidth;
		//计算出被画视图的高度
		mFoldDrawHeight = mFoldMaxHeight < translatedDistancePerFold ? translatedDistancePerFold
				: mFoldMaxHeight;

		float translatedDistanceFoldSquared = translatedDistancePerFold
				* translatedDistancePerFold;

		/*
		 * Calculate the depth of the fold into the screen using pythagorean
		 * theorem.
		 * 根据勾股定理计算出折叠效果的深度
		 */
		float depth = mIsHorizontal ? (float) Math
				.sqrt((double) (mFoldDrawWidth * mFoldDrawWidth - translatedDistanceFoldSquared))
				: (float) Math
						.sqrt((double) (mFoldDrawHeight * mFoldDrawHeight - translatedDistanceFoldSquared));

		/*
		 * The size of some object is always inversely proportional to the
		 * distance it is away from the viewpoint. The constant can be varied to
		 * to affect the amount of perspective.
		 * 这个地方又使用了一个因子，它是根据深度depth来得到的。主要也是用来计算相对的值，体现在高度上。
		 */
		float scaleFactor = DEPTH_CONSTANT / (DEPTH_CONSTANT + depth);

		float scaledWidth, scaledHeight, bottomScaledPoint, topScaledPoint, rightScaledPoint, leftScaledPoint;

		if (mIsHorizontal) {
			//得到变化后的宽度，其实和translatedDistance相差无几
			scaledWidth = mFoldDrawWidth * cTranslationFactor;
			//得到变化后的高度
			scaledHeight = mFoldDrawHeight * scaleFactor;
		} else {
			scaledWidth = mFoldDrawWidth * scaleFactor;
			scaledHeight = mFoldDrawHeight * cTranslationFactor;
		}
		//根据变化后的高度和宽度来计算出坐标点
		topScaledPoint = (mFoldDrawHeight - scaledHeight) / 2.0f;
		bottomScaledPoint = topScaledPoint + scaledHeight;

		leftScaledPoint = (mFoldDrawWidth - scaledWidth) / 2.0f;
		rightScaledPoint = leftScaledPoint + scaledWidth;
		//锚点计算
		float anchorPoint = mIsHorizontal ? mAnchorFactor * mOriginalWidth
				: mAnchorFactor * mOriginalHeight;

		/* The fold along which the anchor point is located. */
		float midFold = mIsHorizontal ? (anchorPoint / mFoldDrawWidth)
				: anchorPoint / mFoldDrawHeight;
		//以下的坐标就是mMatrix方法的参数 表示单个折叠视图
		mSrc[0] = 0;
		mSrc[1] = 0;
		mSrc[2] = 0;
		mSrc[3] = mFoldDrawHeight;
		mSrc[4] = mFoldDrawWidth;
		mSrc[5] = 0;
		mSrc[6] = mFoldDrawWidth;
		mSrc[7] = mFoldDrawHeight;

		/*
		 * Computes the transformation matrix for each fold using the values
		 * calculated above.
		 */
		for (int x = 0; x < mNumberOfFolds; x++) {

			boolean isEven = (x % 2 == 0);

			if (mIsHorizontal) {
				mDst[0] = (anchorPoint > x * mFoldDrawWidth) ? anchorPoint
						+ (x - midFold) * scaledWidth : anchorPoint
						- (midFold - x) * scaledWidth;
				mDst[1] = isEven ? 0 : topScaledPoint;
				mDst[2] = mDst[0];
				mDst[3] = isEven ? mFoldDrawHeight : bottomScaledPoint;
				mDst[4] = (anchorPoint > (x + 1) * mFoldDrawWidth) ? anchorPoint
						+ (x + 1 - midFold) * scaledWidth
						: anchorPoint - (midFold - x - 1) * scaledWidth;
				mDst[5] = isEven ? topScaledPoint : 0;
				mDst[6] = mDst[4];
				mDst[7] = isEven ? bottomScaledPoint : mFoldDrawHeight;

			} else {
				mDst[0] = isEven ? 0 : leftScaledPoint;
				mDst[1] = (anchorPoint > x * mFoldDrawHeight) ? anchorPoint
						+ (x - midFold) * scaledHeight : anchorPoint
						- (midFold - x) * scaledHeight;
				mDst[2] = isEven ? leftScaledPoint : 0;
				mDst[3] = (anchorPoint > (x + 1) * mFoldDrawHeight) ? anchorPoint
						+ (x + 1 - midFold) * scaledHeight
						: anchorPoint - (midFold - x - 1) * scaledHeight;
				mDst[4] = isEven ? mFoldDrawWidth : rightScaledPoint;
				mDst[5] = mDst[1];
				mDst[6] = isEven ? rightScaledPoint : mFoldDrawWidth;
				mDst[7] = mDst[3];
			}

			/*
			 * Pixel fractions are present for odd number of folds which need to
			 * be rounded off here.
			 */
			for (int y = 0; y < 8; y++) {
				mDst[y] = Math.round(mDst[y]);
			}

			/*
			 * If it so happens that any of the folds have reached a point where
			 * the width or height of that fold is 0, then nothing needs to be
			 * drawn onto the canvas because the view is essentially completely
			 * folded.
			 */
			if (mIsHorizontal) {
				if (mDst[4] <= mDst[0] || mDst[6] <= mDst[2]) {
					mShouldDraw = false;
					return;
				}
			} else {
				if (mDst[3] <= mDst[1] || mDst[7] <= mDst[5]) {
					mShouldDraw = false;
					return;
				}
			}

			/* Sets the shadow and bitmap transformation matrices. 
			 * 对矩形进行变换，
			 * 这个方法就是设置指定的矩阵的src点映射到指定的dst点。这些点代表一个float数组，
			 * 每一点由两个float值组成。比如一个矩形，用数组可以这样表示：[x0,y0,x1,y1,x2,y2,x3,y3]
			 * */
			mMatrix[x].setPolyToPoly(mSrc, 0, mDst, 0, NUM_OF_POLY_POINTS / 2);
		}
		/*
		 * The shadows on the folds are split into two parts: Solid shadows and
		 * gradients. Every other fold has a solid shadow which overlays the
		 * whole fold. Similarly, the folds in between these alternating folds
		 * also have an overlaying shadow. However, it is a gradient that takes
		 * up part of the fold as opposed to a solid shadow overlaying the whole
		 * fold.
		 */

		/* Solid shadow paint object. */
		int alpha = (int) (mFoldFactor * 255 * SHADING_ALPHA);

		mSolidShadow.setColor(Color.argb(alpha, 0, 0, 0));

		if (mIsHorizontal) {
			mShadowGradientMatrix.setScale(mFoldDrawWidth, 1);
			mShadowLinearGradient.setLocalMatrix(mShadowGradientMatrix);
		} else {
			mShadowGradientMatrix.setScale(1, mFoldDrawHeight);
			mShadowLinearGradient.setLocalMatrix(mShadowGradientMatrix);
		}

		mGradientShadow.setAlpha(alpha);
	}
	
	/**
	 * 重载ViewGroup的方法，绘制图形
	 * 
	 * 其实这个方法最主要的两个地方就是，canvas.concat( mMatrix[x])和canvas.clipRect(0, 0, src. right - src.left, src. bottom- src. top)。
	 * 首先在最外层是一个for循环，这个循环根据折叠的数目迭代，本例中这个数值为2，所以将迭代两次。接着从mFoldRectArray数组中取出一个Rect赋值给src，
	 * 然后就调用canvas.concat( mMatrix[x])方法了。我们知道，这个Matrix刚才已经使用setPolyToPoly方法进行变换了，
	 * 那如何将变换后的矩阵的效果应用到视图上呢，就是使用canvas.concat( mMatrix[x])方法，如果没有这个方法，
	 * 那就不会看到折叠的效果。然后就是canvas.clipRect(0, 0, src.right - src.left, src.bottom - src.top)方法了，
	 * 这个方法用于对图形进行裁剪，显示出每一个折叠的视图。需要注意的地方是这个方法要在后续画画操作之前进行剪切才能生效，
	 * 这也就是为什么这个方法在super.dispatchDraw(canvas)之前调用。接着还需要对视图进行平移操作，
	 * canvas.translate(-src.left, 0)，不然的话会显示两个相同的图片。
	 * 
	 */
	@Override
	protected void dispatchDraw(Canvas canvas) {
		/**
		 * If prepareFold has not been called or if preparation has not
		 * completed yet, then no custom drawing will take place so only need to
		 * invoke super's onDraw and return.
		 */
		if (!mIsFoldPrepared || mFoldFactor == 0) {
			super.dispatchDraw(canvas);
			return;
		}

		if (!mShouldDraw) {
			return;
		}

		Rect src;
		/*
		 * Draws the bitmaps and shadows on the canvas with the appropriate
		 * transformations.
		 */
		for (int x = 0; x < mNumberOfFolds; x++) {

			src = mFoldRectArray[x];
			/* The canvas is saved and restored for every individual fold */
			canvas.save();

			/*
			 * Concatenates the canvas with the transformation matrix for the
			 * the segment of the view corresponding to the actual image being
			 * displayed.
			 */
			canvas.concat(mMatrix[x]);
			if (Util.IS_JBMR2 ) {
				mDstRect.set(0, 0, src.width(), src.height());
				canvas.drawBitmap(mFullBitmap, src, mDstRect, null);
			} else {
				/*
				 * The same transformation matrix is used for both the shadow
				 * and the image segment. The canvas is clipped to account for
				 * the size of each fold and is translated so they are drawn in
				 * the right place. The shadow is then drawn on top of the
				 * different folds using the sametransformation matrix.
				 */
				canvas.clipRect(0, 0, src.right - src.left, src.bottom
						- src.top);

				if (mIsHorizontal) {
					canvas.translate(-src.left, 0);
				} else {
					canvas.translate(0, -src.top);
				}

				super.dispatchDraw(canvas);

				if (mIsHorizontal) {
					canvas.translate(src.left, 0);
				} else {
					canvas.translate(0, src.top);
				}
			}
			/* Draws the shadows corresponding to this specific fold. */
			if (x % 2 == 0) {
				canvas.drawRect(0, 0, mFoldDrawWidth, mFoldDrawHeight,
						mSolidShadow);
			} else {
				canvas.drawRect(0, 0, mFoldDrawWidth, mFoldDrawHeight,
						mGradientShadow);
			}

			canvas.restore();
		}
	}

}